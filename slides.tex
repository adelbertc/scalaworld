\documentclass{beamer}

\usetheme{Boadilla}

\usepackage{color}
\usepackage[utf8]{inputenc}
\usepackage{minted}
\usepackage{tikz}
\usepackage{tikz-cd}

\usetikzlibrary{positioning}
\usetikzlibrary{tikzmark}

\title{Simplicity in Composition}
\author{Adelbert Chang}
\date{Scala World 2017}

\logo{\includegraphics[height=1.5cm]{scalaworldlogo.jpg}}

\def\code#1{\texttt{#1}}

\newcommand{\gpause}{\vspace*{-\baselineskip}\pause}

\begin{document}

\frame{\titlepage}

\begin{frame}

  \frametitle{Composition}
  \large

  \begin{itemize}
    \item $A$: type (set) of values \pause
    \item $\oplus$: $A \times A \rightarrow A$ \pause
    \item $1_{A}$: identity for $\oplus$ \pause
  \end{itemize}

  $$x \oplus (y \oplus z) = (x \oplus y) \oplus z$$ \gpause
  $$x = x \oplus 1_{A} = 1_{A} \oplus x$$

\end{frame}

\begin{frame} \Large $$(\mathbb{Z}, +, 0)$$ \end{frame}

\begin{frame} \Large $$(\code{[a]}, +\!\!+, \code{[]})$$ \end{frame}

\begin{frame} \Large $$(A \rightarrow A, \circ, a \mapsto a)$$ \end{frame}

\begin{frame}[fragile]
  \large

  \begin{minted}{scala}

    trait Monoid[A] {
      def combine(x: A, y: A): A
      def empty: A
    }

  \end{minted}

\end{frame}

\tikzstyle{cell} = [rectangle, rounded corners=5pt, thick, draw, text width=0.65cm ]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Folding down list
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
  \centering

  \begin{tikzpicture}[
    every node/.style={text centered, minimum height=2em, node distance=0.5cm}
  ]

    \node [cell] (n1) {1};
    \foreach \i in {2,...,8}
      \pgfmathtruncatemacro{\prev}{\i - 1}
      \node [cell] (n\i) [right=of n\prev] {\i};

  \end{tikzpicture}

\end{frame}

\begin{frame}
  \centering

  \begin{tikzpicture}[
    every node/.style={text centered, minimum height=2em, node distance=0.5cm}
  ]
    \node [cell, text width=1.8cm] (n2) {3};
    \foreach \i in {3,...,8}
      \pgfmathtruncatemacro{\prev}{\i - 1}
      \node [cell] (n\i) [right=of n\prev] {\i};

  \end{tikzpicture}

\end{frame}

\begin{frame}
  \centering

  \begin{tikzpicture}[
    every node/.style={text centered, minimum height=2em, node distance=0.5cm}
  ]

    \node [cell, text width=2.95cm] (n3) {6};
    \foreach \i in {4,...,8}
      \pgfmathtruncatemacro{\prev}{\i - 1}
      \node [cell] (n\i) [right=of n\prev] {\i};

  \end{tikzpicture}

\end{frame}

\begin{frame}
  \centering

  \begin{tikzpicture}[
    every node/.style={text centered, minimum height=2em, node distance=0.5cm}
  ]

    \node [cell, text width=5.95cm] (n5) {15};
    \foreach \i in {6,...,8}
      \pgfmathtruncatemacro{\prev}{\i - 1}
      \node [cell] (n\i) [right=of n\prev] {\i};

  \end{tikzpicture}

\end{frame}

\begin{frame}
  \centering

  \begin{tikzpicture}[
    every node/.style={text centered, minimum height=2em, node distance=0.5cm}
  ]

    \node [cell, text width=8.7cm] (n5) {36};

  \end{tikzpicture}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Parallel folding
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
  \centering

  \begin{tikzpicture}[
    every node/.style={text centered, minimum height=2em, node distance=0.5cm}
  ]

    \node [cell] (n1) {1};
    \foreach \i in {2,...,8}
      \pgfmathtruncatemacro{\prev}{\i - 1}
      \node [cell] (n\i) [right=of n\prev] {\i};

  \end{tikzpicture}

\end{frame}

\begin{frame}
  \centering

  \begin{tikzpicture}[
    every node/.style={text centered, minimum height=2em, node distance=0.5cm}
  ]

    \node [cell, text width=1.8cm] (n1) {3};
    \node [cell, text width=1.8cm] (n2) [right=of n1] {7};
    \node [cell, text width=1.8cm] (n3) [right=of n2] {11};
    \node [cell, text width=1.8cm] (n4) [right=of n3] {15};

  \end{tikzpicture}

\end{frame}

\begin{frame}
  \centering

  \begin{tikzpicture}[
    every node/.style={text centered, minimum height=2em, node distance=0.5cm}
  ]

    \node [cell, text width=4.1cm] (n1) {10};
    \node [cell, text width=4.1cm] (n2) [right=of n1] {26};

  \end{tikzpicture}

\end{frame}

\begin{frame}
  \centering

  \begin{tikzpicture}[
    every node/.style={text centered, minimum height=2em, node distance=0.5cm}
  ]

    \node [cell, text width=8.7cm] (n1) {36};

  \end{tikzpicture}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% TODO: Hierarchy
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
  \centering

  \begin{tikzpicture}[
    every node/.style={text centered, minimum height=2em, node distance=0.5cm}
  ]

    \node [cell, text width=8.7cm] (n1) [above=of n2] {36};
    \node [cell, text width=4.1cm] (n2) {10};
    \node [cell, text width=4.1cm] (n3) [right=of n2] {26};


  \end{tikzpicture}

\end{frame}

\definecolor{darkred}{RGB}{181, 23, 0}
\definecolor{darkblue}{RGB}{0,118,186}

\begin{frame}
  \centering
  \Large

  \textbf{Associative composition}
  allows for \textcolor{darkred}{modular}
  \textcolor{darkblue}{decomposition} and \textcolor{darkblue}{reasoning}.
\end{frame}

\begin{frame}[fragile]

  \frametitle{Composing programs}

  \centering
  \Large

  \begin{minipage}{0.3\textwidth}
    \begin{minted}{scala}

      A

    \end{minted}
  \end{minipage}

\end{frame}

\begin{frame}[fragile]

  \frametitle{Composing programs}

  \centering
  \Large

  \begin{minipage}{0.36\textwidth}
    \begin{minted}{scala}

      F[A]

    \end{minted}
  \end{minipage}

\end{frame}

\begin{frame}[fragile]

  \frametitle{Composing programs}

  \centering
  \Large

  \begin{minipage}{0.70\textwidth}
    \begin{minted}{scala}

      (F[A], F[A]) => F[A]

    \end{minted}
  \end{minipage}

\end{frame}

\begin{frame}[fragile]

  \frametitle{Composing programs}

  \centering
  \Large

  \begin{minipage}{0.70\textwidth}
    \begin{minted}{scala}

      (F[A], F[B]) => F[?]

    \end{minted}
  \end{minipage}

\end{frame}

\begin{frame}[fragile]

  \frametitle{Composing programs}

  \centering
  \Large

  \begin{minipage}{0.8\textwidth}
    \begin{minted}{scala}

      (F[A], F[B]) => F[(A, B)]

    \end{minted}
  \end{minipage}

\end{frame}

\begin{frame}[fragile]

  \frametitle{Composing programs}

  \begin{minted}{scala}

    def zipOption[A, B]
      (oa: Option[A], ob: Option[B]): Option[(A, B)] =

      (oa, ob) match {
        case (Some(a), Some(b)) => Some((a, b))
        case _                  => None
      }

  \end{minted}

\end{frame}

\begin{frame}[fragile]

  \frametitle{Composing programs}

  \begin{minted}{scala}

    def zipList[A, B]
      (la: List[A], lb: List[B]): List[(A, B)] =

      la match {
        case Nil    => Nil
        case h :: t => lb.map((h, _)) ++ zipList(t, f)
      }

  \end{minted}

\end{frame}

\begin{frame}[fragile]

  \frametitle{Composing programs}

  \begin{minted}{scala}

    def zipFunction[A, B, X]
      (f: X => A, g: X => B): X => (A, B) =

      (x: X) => (f(x), g(x))

  \end{minted}

\end{frame}

\begin{frame}[fragile]

  \frametitle{Composing programs}
  \large

  \begin{itemize}
    \item $F(\rule{1ex}{.4pt})$: type of program \pause
    \item $\otimes: F(A) \times F(B) \rightarrow F((A, B))$ \pause
    \item $\eta: A \rightarrow F(A)$ \pause
  \end{itemize}

  $$fa \otimes (fb \oplus fc) \cong (fa \oplus fb) \oplus fc$$ \gpause
  $$fa \cong fa \otimes \eta_{Unit} \cong \eta_{Unit} \otimes fa$$

\end{frame}

\begin{frame}[fragile]

  \begin{minted}{scala}

    trait Monoidal[F[_]] {
      def zip[A, B](fa: F[A], fb: F[B]): F[(A, B)]
      def pure[A](a: A): F[A]

      /*
      def map[A, B](fa: F[A])(f: A => B): F[B]
      */
    }

  \end{minted}

\end{frame}

\begin{frame}[fragile]

  \frametitle{Composing programs}

  \centering
  \Large

  \begin{minipage}{1.0\textwidth}
    \begin{minted}{scala}

      (F[A], F[B]) => F[(A, B)]

    \end{minted}
  \end{minipage}

\end{frame}

\begin{frame}[fragile]

  \frametitle{Composing programs}

  \centering
  \Large

  \begin{minipage}{0.36\textwidth}
    \begin{minted}{scala}

      F[A]

    \end{minted}
  \end{minipage}

\end{frame}

\begin{frame}[fragile]

  \frametitle{Composing dependent programs}

  \centering
  \Large

  \begin{minipage}{0.82\textwidth}
    \begin{minted}{scala}

      (F[A], A => F[B]) => F[B]

    \end{minted}
  \end{minipage}

\end{frame}

\begin{frame}[fragile]

  \frametitle{Composing dependent programs}

  \begin{minted}{scala}

    def flatMapOption[A, B]
      (oa: Option[A], f: A => Option[B]): Option[B] =

      oa match {
        case Some(a) => f(a)
        case None    => None
      }

  \end{minted}

\end{frame}

\begin{frame}[fragile]

  \frametitle{Composing dependent programs}

  \begin{minted}{scala}

    def flatMapList[A, B]
      (la: List[A], f: A => List[B]): List[B] =

      la match {
        case Nil => Nil
        case h :: t => f(h) ++ flatMapList(t, f)
      }

  \end{minted}

\end{frame}

\begin{frame}[fragile]

  \frametitle{Composing dependent programs}

  \begin{minted}{scala}

    def flatMapFunction[A, B, X]
      (fa: X => A, f: A => (X => B)): X => B =

      (x: X) => f(fa(x))(x)

  \end{minted}

\end{frame}

\newcommand{\kcomp}{>\!=\!>}
\newcommand{\bind}{>\!\!>\!=}

\begin{frame}

  \frametitle{Composing dependent programs}
  \large

  \begin{itemize}
    \item $F(\rule{1ex}{.4pt})$: type of program \pause
    \item $\bind: (F(A) \times A \rightarrow F(B)) \rightarrow F(B)$ \pause
    \item $\eta: A \rightarrow F(A)$ \pause
  \end{itemize}

  $$(fa \bind f) \bind g \ \ = \ \ fa \bind (f \kcomp g)$$ \gpause
  $$f(x) \ \ = \ \ \eta(x) \bind f$$ \gpause
  $$fa \ \ = \ \ fa \bind \eta$$

\end{frame}

\begin{frame}[fragile]

  \begin{minted}{scala}

    trait Monad[F[_]] {
      def flatMap[A, B](fa: F[A], f: A => F[B]): F[B]
      def pure[A](a: A): F[A]
    }

  \end{minted}

\end{frame}

\begin{frame}

  \frametitle{A nicer monad}
  \large

  $$(fa \bind f) \bind g \ \ = \ \ fa \bind (f \kcomp g)$$
  $$f(x) \ \ = \ \ \eta(x) \bind f$$
  $$fa \ \ = \ \ fa \bind \eta$$

\end{frame}

\begin{frame}

  \frametitle{A nicer monad}
  \large

  $$f: A \rightarrow F(B)$$
  $$g: B \rightarrow F(C)$$
  $$h: C \rightarrow F(D)$$ \pause
  $$(f \kcomp g) \kcomp h \ \ = \ \ f \kcomp (g \kcomp h)$$ \gpause
  $$f \ \ = \ \ f \kcomp \eta \ \ = \ \ \eta \kcomp f$$

\end{frame}

\begin{frame}
  \centering
  \large

  \textbf{Category theory}
  studies the algebra of composition.
\end{frame}

\begin{frame}[fragile]
  \centering
  \frametitle{Category theory}
  \Large

  \begin{tikzcd}
    & B \arrow[dr, "g"] \\
    A \arrow[ur, "f"] \arrow[rr, "g \circ f"'] && C
  \end{tikzcd}

\end{frame}

\begin{frame}

  \frametitle{Category theory}
  \large

  \begin{itemize}
    \item objects: A, B, C ... \pause
    \item arrows: $f: A \rightarrow B$, $g: B \rightarrow C$ ... \pause
    \item $1_{A}: A \rightarrow A$ \pause
  \end{itemize}

  $$(f \circ g) \circ h = f \circ (g \circ h)$$ \gpause
  $$f = f \circ 1_{A} = 1_{A} \circ f$$

\end{frame}

\begin{frame}[fragile]
  \centering
  \frametitle{Category theory: monoids}
  \Large

  \begin{tikzcd}
    & \bullet \arrow[out=210, in=150, loop, distance=3.0cm, "x"]           % left
              \arrow[out=120, in=60,  loop, distance=3.0cm, "y"]           % top
              \arrow[out=30,  in=-30, loop, distance=3.0cm, "x \oplus y"]  % right
  \end{tikzcd}

\end{frame}

\begin{frame}[fragile]
  \centering
  \frametitle{Category theory: monoids}
  \Large

  \begin{tikzcd}
    & \bullet \arrow[out=210, in=150, loop, distance=3.0cm, "x"]           % left
              \arrow[out=120, in=60,  loop, distance=3.0cm, "y"]           % top
              \arrow[out=30,  in=-30, loop, distance=3.0cm, "x \oplus y"]  % right
              \arrow[out=300, in=240, loop, distance=3.0cm, "1_{A}"]       % bottom
  \end{tikzcd}

\end{frame}

\begin{frame}[fragile]
  \centering
  \frametitle{Category theory: monads}
  \Large

  \pause

  \begin{tikzcd}
    & T(B) \\
    A \arrow[ur, "f"] \arrow[rr, "? \circ f"'] && T(C)
  \end{tikzcd}

  \pause

  $$\bind: (F(A) \times A \rightarrow F(B)) \rightarrow F(B)$$

\end{frame}

\begin{frame}[fragile]
  \centering
  \frametitle{Category theory: monads}
  \Large

  \begin{tikzcd}
    & T(B) \\
    A \arrow[ur, "f"] \arrow[rr, "? \circ f"'] && T(C)
  \end{tikzcd}

  $$\bind: (A \rightarrow F(B)) \rightarrow F(A) \rightarrow F(B)$$

\end{frame}

\begin{frame}[fragile]
  \centering
  \frametitle{Category theory: monads}
  \Large

  \begin{tikzcd}
    & T(B) \arrow[dr, "g^{*}"] \\
    A \arrow[ur, "f"] \arrow[rr, "g^{*} \circ f"'] && T(C)
  \end{tikzcd}

  $$\bind: (A \rightarrow F(B)) \rightarrow F(A) \rightarrow F(B)$$

\end{frame}

\begin{frame}[fragile]
  \centering
  \frametitle{Category theory: monads}
  \Large

  \begin{tikzcd}
    & B \arrow[dr, dashrightarrow, "g'"] \\
    A \arrow[ur, dashrightarrow, "f'"] \arrow[rr, dashrightarrow, "g' \circ f'"'] && C
  \end{tikzcd}

\end{frame}

\begin{frame}[fragile]
  \centering
  \frametitle{Category theory: monads}
  \Large

  \begin{tikzcd}
    & B \arrow[dr, dashrightarrow, "g'"] \arrow[out=120, in=60, loop, dashrightarrow, distance=1.0cm, "1_{B}"] \\
    A \arrow[ur, dashrightarrow, "f'"] \arrow[rr, dashrightarrow, "g' \circ f'"']
      \arrow[out=300, in=240, loop, dashrightarrow, distance=1.0cm, "1_{A}"]
    && C \arrow[out=300, in=240, loop, dashrightarrow, distance=1.0cm, "1_{C}"]
  \end{tikzcd}

\end{frame}

\begin{frame}[fragile]
  \centering
  \frametitle{Category theory: monads}
  \Large

  \begin{tikzcd}
    & B \arrow[dr, dashrightarrow, "g'"] \arrow[out=120, in=60, loop, dashrightarrow, distance=1.0cm, "B \rightarrow T(B)"] \\
    A \arrow[ur, dashrightarrow, "f'"] \arrow[rr, dashrightarrow, "g' \circ f'"']
      \arrow[out=300, in=240, loop, dashrightarrow, distance=1.0cm, "A \rightarrow T(A)"]
    && C \arrow[out=300, in=240, loop, dashrightarrow, distance=1.0cm, "C \rightarrow T(C)"]
  \end{tikzcd}

\end{frame}

\begin{frame}
  \centering
  \large

  Can we compose the composers?
\end{frame}

\begin{frame}[fragile]

  \centering
  \Large

  \begin{minipage}{0.5\textwidth}
    \begin{minted}{scala}

      (A, A) => A

    \end{minted}
  \end{minipage}

\end{frame}

\begin{frame}[fragile]

  \centering
  \large

  \begin{minipage}{0.85\textwidth}
    \begin{minted}{scala}

      (Monoid[A], Monoid[B]) => Monoid[?]

    \end{minted}
  \end{minipage}

\end{frame}

\begin{frame}[fragile]

  \centering
  \large

  \begin{minipage}{0.95\textwidth}
    \begin{minted}{scala}

      (Monoid[A], Monoid[B]) => Monoid[(A, B)]

    \end{minted}
  \end{minipage}

\end{frame}

\begin{frame}[fragile]

  \Large

  $$ (x_{1}, y_{1}) \oplus (x_{2}, y_{2}) $$

\end{frame}

\begin{frame}[fragile]

  \centering
  \Large

  $$ (x_{1} \oplus x_{2}, y_{1} \oplus y_{2}) $$

\end{frame}

\begin{frame}[fragile]

  \centering
  \large

  \begin{minipage}{0.65\textwidth}
    \begin{minted}{scala}

      (F[A], F[B]) => F[(A, B)]

    \end{minted}
  \end{minipage}

\end{frame}

\begin{frame}[fragile]

  \centering
  \large

  \begin{minipage}{9.95\textwidth}
    \begin{minted}{scala}

      (Monoidal[F], Monoidal[G]) => Monoidal[?]

    \end{minted}
  \end{minipage}

\end{frame}

\begin{frame}[fragile]

  \centering
  \large

  \begin{minipage}{0.95\textwidth}
    \begin{minted}{scala}

      type L[X] = (F[X], G[X])
      (Monoidal[F], Monoidal[G]) => Monoidal[L]

    \end{minted}
  \end{minipage}

\end{frame}

\begin{frame}[fragile]

  \centering
  \large

  \begin{minipage}{0.80\textwidth}
    \begin{minted}{scala}

      type L[X] = (F[X], G[X])
      (Monad[F], Monad[G]) => Monad[L]

    \end{minted}
  \end{minipage}

\end{frame}

\begin{frame}[fragile]

  \centering
  \large

  \begin{minipage}{0.95\textwidth}
    \begin{minted}{scala}

      type L[X] = F[G[X]]
      (Monoidal[F], Monoidal[G]) => Monoidal[L]

    \end{minted}
  \end{minipage}

\end{frame}

\begin{frame}[fragile]

  \centering
  \large

  \begin{minipage}{0.75\textwidth}
    \begin{minted}{scala}

      type L[X] = F[G[X]]
      (Monad[F], Monad[G]) => Monad[L]

    \end{minted}
  \end{minipage}

\end{frame}

\begin{frame}[fragile]

  \centering
  \large

  \begin{minipage}{0.75\textwidth}
    \begin{minted}{scala}

      type L[X] = F[G[X]]
      (Monad[F], Monad[G]) => Monad[L] % TODO: Cross out

    \end{minted}
  \end{minipage}

\end{frame}

\end{document}
